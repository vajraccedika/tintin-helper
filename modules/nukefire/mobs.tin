#class mobs kill
#class mobs open

#nop --
#nop Class Definitions
#nop --

#var nukefire/mobs-description {Manage mobs and mob database for Nukefire.}
#var nukefire/mobs-help {TBA}

#nop --
#nop Modloader Stuff
#nop --

#alias nukefire/mobs-register {
	#if {@isloaded{modloader}} {
		register_module nukefire/mobs
	} {
		fail_module nukefire/mobs unknown reason
	}
}

event_register mobLine mobs {add_mob {%2}}
event_register roomLook mobs {clear_mobs}

#action {~^\e[0;33m%1$} {
	event_raise mobLine {%1}
} {4}

#action  {~\e[0m\e[0;33m%1$} {
	event_raise mobLine {%1}
} {4}

#alias add_mob {
	#nop %0;
	diaLog zone add_mob received input:%1:;
	#var _mob @ansiStrip{%1};
	#replace _mob {(Eldritch Aura)} {};
	#replace _mob {(s)} {};
	#replace _mob {(leader)} {};
	#replace _mob {(group)} {};
	diaLog zone pre-stripped mob is "$_mob";
	#format {_mob} {%p} {$_mob}; 
	diaLog zone post-stripped mob is "$_mob";
	#if {$room[looking]==1} {
		diaLog zone room[looking] is true;
		diaLog zone Priority for mob is @mobsPRFromLong{$_mob};
		#list mobs_in_room[@mobsPRFromLong{$_mob}] add {$_mob}
	}
}

#alias test_hash {
	#local _arg %1;
	#var _arg2 %1;
	#format _raw_hash {%H} {%1};
	#format _loc_hash {%H} {$_arg};
	#format _var_hash {%H} {$_arg2};
	#echo {<cfa>Does $_raw_hash == $_var_hash? == $_loc_hash}
}

#alias clear_mobs {
	#nop %0;
	#list mobs_in_room clear
}

#alias read_mobs {
	#nop %0;
	#var mobs_data 1;
	#var mobsdb {${char_name}_mobs};
	#class mobsdb kill;
	#class {mobsdb} {open};
	#var mobsKWHash null;
	#var mobsPRHash null;
	#nop -- included for debug uinfo mobs mobsKWHash: $mobsKWHash;
	#nop -- uinfo mobs mobsPRHash: $mobsPRHash;
	#read $db/${mobsdb}.db;
	#if {$mobs_data==1} {uinfo mobs Reading mobs database for '$mobsdb'.};
	#class {mobsdb} {close};
}

#alias {write_mobs} {
	#var mobsdb ${char_name}_mobs;
	#class {mobsdb} {write} {$db/${mobsdb}.db};
}

#alias init_mobs {
	#var mobsKWHash null;
	#var mobsPRHash null;
}

#tab showmobs
#alias showmobs {
	#var tot_in_room 0;
	#if {&mobs_in_room[]>0} {
		#echo {<170>Num    Mobs in Room                             KeyW  Pr  };
		#echo {-------------------------------------------------------------------};
			#foreach {*mobs_in_room[%*]} {_p} {
				#foreach {*mobs_in_room[$_p][%*]} {_i} {
					#math tot_in_room $tot_in_room + 1;
					diaLog zone Mob:$_i is $mobs_in_room[$_i];
					#var _mob_inroom $mobs_in_room[$_p][$_i];
					#var _kw {@mobsKWFromLong{$_mob_inroom}};
					#var _pr {@mobsPRFromLong{$_mob_inroom}};
					#format mobline {[%+2s]<370><dca> %-42.42s<070> (<170>%.3s<070>) (%s<070>)} 
					{$tot_in_room}
					{$mobs_in_room[$_p][$_i]}
					{$_kw}
					{@prColor{$_pr}};
					#echo $mobline
			}
		};
		uinfo mobs To add a mob to the DB use: `DBAddMob` <mobnumber> <keyw> <priority>;
		uinfo mobs To remove a mob, use: `DBRemoveMob` <mobnumber>
	};
	#else {
		uinfo mobs No mobs in room.;
		#cr
	}
}

#tab DBAddMob
#alias {DBAddMob} {
	#if {"%1"!="" && "%2"!="" && "%3"!=""} {
			#var {roomIndex} {%1};
			#var {keyw_tmp} {%2};
			#var {pr_tmp} {%3};
			#var tot_in_room 0;
			#foreach {*mobs_in_room[%*]} {_i} {
					#foreach {$mobs_in_room[$_i][%*]} {_j} {
							#math tot_in_room $tot_in_room+1;
							#if {$roomIndex==$tot_in_room} {
									#var mobsKWHash[@hash{$_j}] $keyw_tmp;
									#var mobsPRHash[@hash{$_j}] $pr_tmp;
									write_mobs;
									#format {addMob} {%.42s} {$_j};
									uinfo mobs Mob $addMob with key '$keyw_tmp' added to DB.
							}
					}
			};
	};
	#else {
			uinfo mobs You must provide 3 arguments, type showMobs for help.
	}
}

#alias {DBRemoveMob} {
	#var tot_in_room 0;
	#if {@isD{%1}} {
		diaLog path DB remove arg is digit;
			#foreach {*mobs_in_room[%*]} {_i} {
					#foreach {$mobs_in_room[$_i][%*]} {_j} {
							#math tot_in_room $tot_in_room+1;
							#if {"%1"=="$tot_in_room"} {diaLog kill checking $_j;
									#if {&mobsKWHash[@hash{$_j}]} {
											#unvar mobsKWHash[@hash{$_j}];
											#unvar mobsPRHash[@hash{$_j}];
											#format {remMob}  {%.42s} {$_j};
											write_mobs;
											uinfo mobs Mob $remMob removed from database.
									} {
											uinfo mobs Mob not in database.
									}
							}
					}
			}
	};
	#else {
			uinfo mobs You must provide the mob in room number.
	}
}

#tab DBRemoveMob

#nop -- iterates through mobs_in_room, attacking if we have a valid keyword. If we come to the end
#nop -- of a priority section we clear that priority.
#alias {mobAttack} {
	#if {&mobs_in_room[]>0} {
			#if {"$MSDP_POSITION"!="fighting"} {
					#foreach {*mobs_in_room[%*]} {_mir} {
							#if {&mobs_in_room[$_mir][1]} {
									#if {"@mobsKWFromLong{$mobs_in_room[$_mir][1]}"!="null"} {
											#line sub {vars;func} {$skill[opener] @mobsKWFromLong{$mobs_in_room[$_mir][1]}};
											diaLog path doing attack on @mobsKWFromLong{$mobs_in_room[$_mir][1]};
											diaLog path Mobs in room: &mobs_in_room[];
											#list mobs_in_room[$_mir] delete 1;
											diaLog path doing mobs in room $_mir delete spot 1;
											#if {&{mobs_in_room[$_mir][1]}==0} {
													#unvar mobs_in_room[$_mir];
													diaLog path doing pr list delete
											};
											#break
									};
							}
					}
			};
			#else {
					uinfo mobs Fighting, not attacking.
			}
	};
	#else {
			uinfo mobs No mobs in room.;
			event_raise clearSpellLock
	}
}

#alias kk mobAttack

#nop --
#nop functions
#nop --

#function mobsKWFromLong {
	diaLog kill KWFromLong received arg %0;
	#format _mktmp {%H} {%0};
	#if {&mobsKWHash[$_mktmp]} {
			diaLog kill Returning $mobsKWHash[$_mktmp];
			#return $mobsKWHash[$_mktmp]
	} {
			#return null
	}
}

#nop -- returns priority, if one exists, 1 (highest) if none
#function mobsPRFromLong {
	diaLog zone mobs PR from long received arg:"%0";
	#format _mptmp {%H} {%0};
	#if {&mobsPRHash[$_mptmp]} {
			#return $mobsPRHash[$_mptmp]
	} {
			#return 1
	}
}

#function {prColor} {
	#if {%1<2} {#return <118>%1};
	#if {%1<3} {#return <138>%1};
	#return <148>%1
}

#function killableMobs {
	#local _kmobs 0;
	#foreach {*mobs_in_room[%*]} {_km} {
			#foreach {$mobs_in_room[$_km][%*]} {_kkm} {
					diaLog kill Sending arg $_kkm to mobsKWFromLong;
					#var KW_tmp @mobsKWFromLong{$_kkm};
					#if {"$KW_tmp"!="null"} {
							#return 1;
							#break
					};
			}
	};
	#return $_kmobs
}

read_mobs

#class mobs close