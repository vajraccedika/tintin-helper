#class inventory kill
#class inventory open

#nop --
#nop Class Definitions
#nop --

#var nukefire/inventory-description {Manages room contents, eventually inventory.}
#var nukefire/inventory-help {
	Currently just captures room contents.
}

#nop --
#nop Modloader Stuff
#nop --

#alias nukefire/inventory-register {
	#if {@isloaded{modloader}} {
		register_module nukefire/inventory
	} {
		fail_module nukefire/inventory unknown reason
	}
}

event_register roomContents update_contents {update_contents %2 {%3}}
event_register roomLook clear_contents {clear_contents}

#action {~^\e[0;32m({(\s?\d+)}) \e[0;32m%3$} {
	event_raise roomContents %1 {%3}
}

#action {~^\e[0m\e[0;32m({(\s?\d+)}) \e[0;32m%3$} {
	event_raise roomContents %1 {%3}
}

#action {~^\e[0;32m\e[0;32m%1$} {
	event_raise roomContents 1 {%1}
}

#action {~^\e[0m\e[0;32m\e[0;32m%1$} {
	event_raise roomContents 1 {%1}
}

#action {^You give %1 to %2.$} {
	#nop track-item give %1 %2
}

#action {^You get %1 from %2.$} {
	#nop track-item get %1 from %2
}

#action {^You drop %1.$} {
	#nop track-item drop %1 at room[name]/room[msdp][room-vnum]
}

#action {^You get %1.$} {
	#nop track-item get %1 at room[name]/room[msdp-room-vnum]
}

#action {^%1 {(used)|(carried)|(here)}:$} {
	#nop capture_contents %1 %2
}

#action {^You put %1 in %2.$} {
	#nop track-item put %1 %2
}

#nop --
#nop Alias
#nop --

#alias update_contents {
	#nop %0;
	#format _n_items %p %1;
	#var _tmp_item %2;
	#if {$_n_items > 1} {
		#loop 1 $_n_items _rc {
			#list room_contents add $_tmp_item
		}
	};
	#else {
		#list room_contents add $_tmp_item
	}
	diaLog room got args:%1:%2
}

#alias clear_contents {
	#nop %0;
	#unvar room_contents
}

#alias gg {
	#nop rem $cont_key;
	g %1 $cont_key;
	#nop wear $cont_key
}

#alias pack {
	#nop rem $cont_key;
	put %1 $cont_key;
	#nop wear $cont_key
}

#alias ccs {
	#nop rem $cont_key;
	l i $cont_key;
	#nop wear $cont_key
}

#class inventory close