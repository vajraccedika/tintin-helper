#nop --
#nop Class Definitions
#nop --

#var queues-description {Action queues}
#var queues-help {
A command queueing system with priorities.\n
\n
To use, run queueAdd <priority> <command>.\n
\n
Valid queues in order of execution are:\n
priority, heal, any (executes at any time), combat (executes if in combat),\n
nco (non-combat operation), and move.\n
\n
There is a shortcut command for NCO (nco <command>).\n
Combat queues clear at the end of combat automatically.\n
}

#nop --
#nop Modloader Stuff
#nop --

#alias queues-register {
	#if {@isloaded{modloader}} {
		register_module queues;
        queue_init;
		queue_block
	} {
		fail_module queues unknown reason
	}
}

#nop --
#nop -- Events
#nop --

#event {VARIABLE UPDATED _queue[combat]} {
    event_raise {variable _queue[combat]} {%1}
}

#nop --
#nop -- Vars
#nop --

#var spellLock 0;

#list spellValidPositions create Flying Fighting Mounted Standing Swimming Hovering;

#alias queue_init {
    #foreach {priority;heal;any;combat;nco;move} {_tmp} {
       #if {!&{_queue[$_tmp]}} {
           #list _queue[$_tmp] create;
       };
    }
}

#nop new queueAdd - for tasks that are exclusive, like heal
#nop order: queue, command, task, exclusive
#nop eg: queueAdd heal {invig anatta} {heal anatta} exclusive
#alias {queueAdd} {
    #var _q %1;
    #var {_cmd} %2;
    #var {_task} %3;
    #if {"$_task" == ""} {
        #var {_task} $_cmd
    };
    #var add[_cmd] $_cmd;
    #var add[_task] $_task;
    #var {_exc} %4;
    #if {"$_exc" == "exclusive"} {
        #var sindex @queue_task{$_q;$_task};
        #if {$sindex} {
            #if {"$_queue[$_q][$sindex]" == "{{$add}}"} {
                #nop
            };
            #else {
                info spell Replacing "$_queue[$_q][$sindex][_cmd]" with "$_cmd" at position $sindex in $_q queue;
                #var _queue[$_q][$sindex][_cmd] {$_cmd};
            }
        };
        #else {
            info spell Adding command "$_cmd" to $_q queue;
            #list _queue[$_q] add {{$add}}
        }
    };
    #else {
        #var sindex @queue_find{$_q;$_cmd};
        #if {$sindex} {
            info spell Not adding "$_cmd" as it is already in $_q queue at position $sindex;
        };
        #else {
            info spell Adding command "$_cmd" to $_q queue;
            #list _queue[$_q] add {{$add}};
            queue_block
        };
    };
    #unvar add
}

#nop original queueAdd
#nop #alias {queueAdd %1 %2} {
    #list _queue[%1] find {%2} {sindex};
    #if {$sindex} {
        info spell Not adding "%2" as it is already in list at position $sindex;
    }   {
        info spell Adding command "%2" to %1 queue;
        #list _queue[%1] add {%2};
        queue_block
    };
}

#alias {nco %1} {queueAdd nco {%1}}

#alias queueRunner {
    #unvar _q_cmd;
    #if { @mpoch{} > $spellLock} {
        #if {&{_queue[priority][]}} {
            #if {@spell_can_cast{}} {
                #var _q_cmd $_queue[priority][1][_cmd];
                info spell $_q_cmd;
                spell_cast_actual $_q_cmd;
                #list {_queue[priority]} delete 1;
                queue_block;
                #break
            };
        };
        #if {&{_queue[heal][]}} {
            #if {@spell_can_cast{}} {
                #var _q_cmd $_queue[heal][1][_cmd];
                info spell Executing $_q_cmd;
                spell_cast_actual $_q_cmd;
                #list {_queue[heal]} delete 1;
                queue_block;
                #break
            };
        };
        #if {&{_queue[any][]}} {
            #if {@spell_can_cast{}} {
                #var _q_cmd $_queue[any][1][_cmd];
                info spell Executing $_q_cmd;
                spell_cast_actual $_q_cmd;
                #list {_queue[any]} delete 1;
                queue_block;
                #break
            };
        };
        #if {&{_queue[combat][]}} {
            #if {"$MSDP_POSITION" == "Fighting"} {
                #if {@spell_can_cast{}} {
                    #var _q_cmd $_queue[combat][1][_cmd];
                    info spell Executing $_q_cmd;
                    spell_cast_actual $_q_cmd;
                    #list {_queue[combat]} delete 1;
                    queue_block;
                    #break
                };
            } {
                info spell Not in combat, clearing spell queue;
                #list {_queue[combat]} clear;
            }
        };
        #if {&{_queue[nco][]}} {
            #if {"$MSDP_POSITION" != "Fighting"} {
                #if {@spell_can_cast{}} {
                    #var _q_cmd $_queue[nco][1][_cmd];
                    info spell Executing $_q_cmd;
                    spell_cast_actual $_q_cmd;
                    #list {_queue[nco]} delete 1;
                    queue_block;
                    #break
                };
            };
        };
        #if {&{_queue[move][]}} {
            #if {"$MSDP_POSITION" != "Fighting"} {
                #if {@spell_can_cast{}} {
                    #var _q_cmd $_queue[move][1][_cmd];
                    info spell Executing $_q_cmd;
                    spell_cast_actual $_q_cmd;
                    #list {_queue[move]} delete 1;
                    queue_block;
                    #break
                };
            };
        };
    }
}

#alias spell_cast_actual {
    #list spellParts create %0;
    info cast %0;
    %0;
    #math spellLock { @max{$spellLock;@mpoch{}} + @spellDelay{$spellParts[1]}}
}

#alias {queue_block} {

    #format {queue_block} {<388>%-44s<088>\nPriority: %d     Heal: %d     Any: %d\n  Combat: %d      NCO: %d    Move: %d}
    	{Action Queues}
        {&{_queue[priority][]}}
        {&{_queue[heal][]}}
        {&{_queue[any][]}}
        {&{_queue[combat][]}}
        {&{_queue[nco][]}}
		{&{_queue[move][]}};

	#if {@is_alias{display_right_tiles}} {display_right_tiles};
}

#nop -- ---------------------------------------------------------------
#nop -- Functions
#nop -- ---------------------------------------------------------------

#function {spell_can_cast} {
    #var can_cast 1;
    #list spellValidPositions find {$MSDP_POSITION} {check};
    #if {$check == 0} { #var can_cast 0};
    #regex $PLAYER_FLAGS {-Knees-} { #var can_cast 0 };
    #regex $PLAYER_FLAGS {>BASH<}  { #var can_cast 0 };
    #return $can_cast
}

#nop -- Spell delays are in 1000ths of a second;
#func spellDelay {
    #switch {"%1"} {
        #case {"heal"} #var _delay 2200;
        #case {"convert"} #var _delay 12000;
        #case {"shapechange"} #var _delay 4000;
        #case {"fst"} #var _delay 3000;
        #case {"charge"} #var _delay 3000;
        #case {"smart_move"} #var _delay 250;
        #case {"#path"} #var _delay 200;
        #case {"mobAttack"} #var _delay 8000;
        #case {"fkill"} #var _delay 5000;
        #case {"get"} #var _delay 500;
        #case {"drop"} #var _delay 500;
        #case {"harvest"} #var _delay 0;
        #case {"extract"} #var _delay 3000;
        #case {"hellstream"} #var _delay 1000;
        #case {"selfrepair"} #var _delay 3500;
        #case {"invig"} #var _delay 2200;
        #case {"kill"} #var _delay 1000;
        #case {"hit"} #var _delay 500;
        #case {"ambush"} #var _delay 0;
        #case {"circle"} #var _delay 8000;
        #case {"backstab"} #var _delay 3500;
        #case {"rejuv"} #var _delay 2200;
        #case {"disembowel"} #var _delay 5200;
        #case {"pound"} #var _delay 4700;
        #case {"neural"} #var _delay 6200;
        #case {"grapple"} #var _delay 6200;
        #case {"rogue"} #var _delay 6200;
        #case {"dagger"} #var _delay 9200;
        #case {"join"} #var _delay 1000;
        #case {"look"} #var _delay 1000;
        #case {"pick"} #var _delay 1000;
        #case {"verify_room"} #var _delay 500;
        #case {"get_one_item"} #var _delay 500;
        #case {"recite"} #var _delay 500;
        #case {"gg"} #var _delay 500;
        #case {"request_recall"} #var _delay 500;
        #case {"bs"} #var _delay 2200;
        #case {"ka"} #var _delay 1000;
        #case {"overboost"} #var _delay 3000;
        #case {"flurry"} #var _delay 4200;
        #case {"rend"} #var _delay 3000;
        #case {"psiattack"} #var _delay 6000;
        #case {"psiblast"} #var _delay 6000;
        #case {"scar"} #var _delay 5000;
        #case {"radblast"} #var _delay 6000;
        #case {"ww"} #var _delay 6000;
        #case {"headbutt"} #var _delay 5000;
        #case {"sonic"} #var _delay 4000;
        #case {"hbs""} #var _delay 3000;
        #case {"hd"} #var _delay 5000;
        #case {"suplex"} #var _delay 5000;
        #case {"firemin"} #var _delay 3500;
        #case {"hstomp"} #var _delay 4200;
        #case {"chainsaw"} #var _delay 3200;
        #case {"devour"} #var _delay 100;
        #case {"gslam"} #var _delay 4200;
        #default {
            #var _delay 2000;
            info spell Unknown delay for %1, using $_delay ms
            };
    };
    #return $_delay
}

#function queue_task {
    #local _tmp_queue %1;
    #local _tmp_task %2;
    #foreach {*_queue[$_tmp_queue][%*]} {_qt} {
        diaLog q Loop idx=$_qt;
        diaLog q tmp_queue="$_tmp_queue";
        diaLog q tmp_task="$_tmp_task";
        diaLog q loop task="$_queue[$_tmp_queue][$_qt][_task]";
        #if {"$_queue[$_tmp_queue][$_qt][_task]" == "$_tmp_task"} {
            #return $_qt
        }
    };
    #return 0
}

#function queue_find {
    #local {_tmp_queue} {%1};
    #local {_tmp_cmd} {%2};
    #foreach {*_queue[$_tmp_queue][%*]} {_qc} {
        diaLog q loop idx=$_qc;
        diaLog q loop chunk cmd="$_queue[$_tmp_queue][$_qc][_cmd]";
        diaLog q loop chunk task="$_queue[$_tmp_queue][$_qc][_cmd]";
        #var $_queue[$_tmp_queue][$_qc];
        #if {"$_queue[$_tmp_queue][$_qc][_cmd]" == "$_tmp_cmd"} {
            #return $_qc
        }
    };
    #return 0
}
#nop -- ---------------------------------------------------------------
#nop -- Ticks
#nop -- ---------------------------------------------------------------
#tick {queue runner} {queueRunner} {0.2};
event_register {VARIABLE UPDATED spellqueue} queues {queue_block}

#nop -- vim: syntax=tt
